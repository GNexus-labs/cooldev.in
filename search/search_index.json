{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Page under construction","text":""},{"location":"linux/fixing_non_booting_kernel/","title":"Fixing a non booting kernel based on custom kernel config file","text":"<p>Recently I was trying to migrate my kernel config across Virtual Box, VMware and Qemu based VM's and noticed that in some of the cases, I was not able to boot into the kernel at all. I did enable vmware, virtual box and qemu specific options in the kernel but still the kernel was not booting up (It was booting up on my machine but not on a friend's machine). Looking deep into the problem I noticed that the versions of vmware and qemu were different than that of my machine.</p>"},{"location":"linux/fixing_non_booting_kernel/#now-how-to-solve-this-issue","title":"Now how to solve this issue?","text":"<p>Well, I cannot adjust the config for every version of vmware, qemu or virtual box, so we need to find a way so that the person using this config can fix it by themselves. Thats where localmodconfig comes in</p> <p>So make has a target called <code>localmodconfig</code> that enables all the modules that are currently being used by the kernel. It will also deselect the modules which are currently not being used by kernel which in turn allows us to create a minimal kernel config. Not only that, <code>localmodconfig</code> can also use the <code>.config</code> file present in the kernel build directory. This allows us to have a base kernel with necessary options already enabled.</p> <p>So lets begin fixing our config</p>"},{"location":"linux/fixing_non_booting_kernel/#step-1-cleaning-the-kernel","title":"Step 1 : Cleaning the Kernel","text":"<p>We will start with a fresh build of the kernel so reboot into the default kernel and switch to the kernel build directory and run <code>make mrproper</code>. Invoking this target will ensure that all the build artifacts generated during the build will be removed (including the config file). </p>"},{"location":"linux/fixing_non_booting_kernel/#step-2-copying-the-config-file","title":"Step 2 : Copying the config file","text":"<p>Copy the config file into the kernel build directory and rename it to .config. After that run <code>make nconfig</code> or <code>make menuconfig</code> and press escape (and save the config if a prompt appears). Doing this will update the config file for the kernel version being used.</p>"},{"location":"linux/fixing_non_booting_kernel/#step-3-running-localmodconfig","title":"Step 3 : Running localmodconfig","text":"<p>Run <code>make localmodconfig</code> to enable modules presently being used by the kernel. If there are no warnings or errors proceed with the kernel compilation (You can run <code>menuconfig</code> or <code>nconfig</code> to see if important options are enabled).</p> <p>But if there are some warnings saying that the config option is disabled or not present go to Step 4</p>"},{"location":"linux/fixing_non_booting_kernel/#step-4-setting-additional-config-options","title":"Step 4 : Setting additional config options","text":"<p>Looking at the messages given by local modconfig, we can see that the last word of these messages contains the <code>config option (starting with CONFIG)</code> that needs to be set in the <code>.config</code> file. So just open the file using your favourite text editor and add/edit the config options mentioned before and set it to <code>y</code> (or <code>m</code>).Run <code>make menuconfig</code> or <code>make nconfig</code> and save the config file. </p> <p>If there are too many options to be configured, you can use <code>awk</code> and <code>sed</code> to add the config options automatically</p> <ul> <li>First save the output of <code>localmodconfig</code> in a text file <pre><code>make localmodconfig &gt; add_opts.txt 2&gt;&amp;1\n</code></pre></li> <li>Now run the <code>awk</code> command to get the last column representing the config option and save it to a new file <pre><code>awk '{print $(NF)}' add_opts.txt &gt; add_opts_cleaned.txt       \n</code></pre></li> <li>Now to put <code>=y</code> in front of these configs we use the <code>sed</code> command <pre><code>sed -i s/$/=y/ add_opts_cleaned.txt\n</code></pre></li> <li>Finally open the file, take a look at if everything is correct and copy paste   the entire content of the file into <code>.config</code> file</li> <li>Now run <code>make menuconfig or make nconfig</code>. These targets will automatically   set the additional config options required. Now press <code>ESC</code> key on your   keyboard and save the configuration.</li> </ul>"},{"location":"linux/fixing_non_booting_kernel/#step-5-continuing-the-compilation","title":"Step 5 : Continuing the Compilation","text":"<p>Continue the kernel compilation by running <code>make -j$(nproc)</code></p>"},{"location":"linux/fixing_non_booting_kernel/#conclusion","title":"Conclusion","text":"<p>Using this method will help you to boot into the kernel. If you want to get  a complete list of the kernel modules required (for running everything as per your requirements, you can have a look at modprobed-db</p>"},{"location":"linux/fixing_non_booting_kernel/#additional-references","title":"Additional References","text":"<p>Learning Awk Is Essential For Linux Users</p> <p>Intro to Sed</p>"},{"location":"linux/implement_sys_call_linux/","title":"How to Implement a System Call in Linux","text":"<p>In this post we will learn about how to implement a simple system call in Linux that will print <code>Invoked Hello System Call</code>  into the kernel log buffer.</p>"},{"location":"linux/implement_sys_call_linux/#background","title":"Background","text":"<p>Following files will be modified once we complete the implementation of this System Call :</p> <ul> <li>syscall_64.tbl -- located under arch/x86/entry/syscalls</li> </ul> <p>syscall_64.tbl acts as the registry that kernel uses to maintain the record of all the system calls available. The kernel scripts parse this file and associate the system call number with the function to be invoked.</p> <ul> <li>kernel Makefile -- root directory of kernel source</li> </ul> <p>This is the main makefile defined in the root directory of the <code>linux-kernel-x</code> folder. When creating a system call we have 3 options on where to the define the system call itself.</p> <ul> <li>If it is related to any subsystem then define the SystemCall inside the perticular folder</li> <li>If it is a miscellaneous system call then define it inside <code>kernel/sys.c</code></li> <li>Define it inside a seperate directory within the kernel source.</li> </ul> <p>We are going with the third option here. So we will define a directory that contains the implementation of the system call and we will link it back to the kernel. In order to link back to the kernel, we  will be required to modify the makefile.</p>"},{"location":"linux/implement_sys_call_linux/#steps","title":"Steps","text":"<ul> <li>Open <code>syscall_64.tbl</code> under <code>arch/x86/entry/syscalls</code> and add an entry as shown below</li> </ul> <p><pre><code>/* -- snip -- */\n450 common  set_mempolicy_home_node sys_set_mempolicy_home_node                                                                       \n451 common  hello_system_call   sys_hello\n/* -- snip -- */\n</code></pre> The first value indicates the unique number used to identify that system call. The second value indicates the ABI ( In our case we dont care if its x86 or amd64 so common ). The third value indicates the name of the system call which in our case is hello_system_call and fourth value is the function itself that needs to be invoked when a system call with this number is invoked.</p> <ul> <li> <p>Now create a directory named <code>hello_syscall</code> in the root of the linux kernel source and create two files in the directory</p> <ul> <li>Makefile</li> <li>hello_syscall.c</li> </ul> </li> <li> <p>Write the Implementation of system call inside hello_syscall.c</p> </li> </ul> <p><pre><code>#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\n\nSYSCALL_DEFINE0(hello)\n{\n    printk(KERN_INFO \"Invoked Hello System Call\");\n    return 0;\n}\n</code></pre> The <code>SYSCALL_DEFINEN</code> macros allow you to define a system call without getting involved in the details of the function signature. You can implement the system call without using the <code>SYSCALL_DEFINEN</code> macro as well (asmlinkage void ..) but there might be some additional metadata passed by your archiecture to the systemcall which you will have to account for explicitly. Therefore it is best to use these macros to define the system call in a portable manner</p> <ul> <li>Now implement the Makefile as follows</li> </ul> <p><pre><code>obj-y := hello_syscall.o\n</code></pre> What this makefile does is that it tells the kernel build system (kbuild) to generate an object file called <code>hello_syscall.o</code>  which will be generated from <code>hello_syscall.c</code>  or <code>hello_syscall.S</code> (asm file) in the same directory. <code>y</code> here refers to yes it must be built. Other values include</p> <pre><code>- m : Build it as a module\n- $(CONFIG_**) : The decision for building this file is based on the value set for the kernel config `CONFIG**`\n</code></pre> <ul> <li>Now get back to the root of the kernel source and open the Makefile </li> <li>Navigate to line <code>1103</code> or search for the first entry of `ifeq ($(KBUILD_EXTMOD),)`` in the Makefile</li> <li>There add your system call directory to the list of directories to be built and linked to the kernel </li> </ul> <pre><code>ifeq ($(KBUILD_EXTMOD),)                                                                                                              \ncore-y          += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ hello_syscall/ \ncore-$(CONFIG_BLOCK)    += block/                                                                                                     \ncore-$(CONFIG_IO_URING) += io_uring/\n</code></pre> <ul> <li>Now save the file and and compile and install the kernel</li> </ul> <pre><code>make -j$(nproc)\nsudo make modules_install\nsudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-***\nsudo mkinitcpio -k 5.19.9 -g /boot/initramfs-***.img\ngrub-mkconfig -o /boot/grub/grub.cfg\nreboot\n\n# replace *** with any string like \"linux_abc\" or version number in both commands(eg. /boot/vmlinuz-linux_abc  &amp; initramfs-linux_abc.img)\n</code></pre> <ul> <li>Once you have rebooted the kernel(make sure you boot with the new compiled kernel from advanced options while rebooting), test the systemcall using the following C program</li> </ul> <p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;sys/syscall.h&gt;\n#include &lt;linux/kernel.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\n\n#define HELLO_SYS_CALL 451\n\nint main()\n{\n    long sys_call_status;\n\n    sys_call_status = syscall(HELLO_SYS_CALL);\n\n    if (!sys_call_status)\n    {\n        printf(\"Successfully invoked system call 451\\n\");\n    }\n\n    return 0;\n}\n</code></pre> - Compile the file using </p> <p><pre><code>gcc -o test test.c\n</code></pre> - Run the compiled file</p> <p><pre><code>./test\n</code></pre> - Now in the kernel buffer you should see a message printed as shown below</p> <pre><code>sudo dmesg\n\n-- Snip -- \n[ 4196.683788] Invoked Hello System Call\n</code></pre>"},{"location":"linux/implement_sys_call_linux/#additional-references","title":"Additional references","text":"<ul> <li>Introduction to System Call</li> <li>Kbuild System</li> <li>Writing a system call in linux</li> </ul>"},{"location":"personal/vimclutch/","title":"My Experience on Building and Using Vim Clutch","text":"<p>Few weeks back, I was scrolling through r/Neovim on reddit and noticed a post that mentioned about <code>vim clutch</code>. I got intrigued by the idea of using a foot pedal to switch modes in vim and decided to give this project a try.</p> <p>So before starting, lets understand what vim clutch is and discuss the motivation behind building such a device.</p>"},{"location":"personal/vimclutch/#what-is-vim-clutch","title":"What is VIM Clutch?","text":"<p>vim clutch is a footpedal that allows you to go to to insert mode when the pedal is pressed and to normal mode when the pedal is released.  It is primarily designed as  a means of convenience and to improve the text editing speed of users using vim/neovim.</p> <p>The idea for this device was proposed by  Aleksandr Levchuk </p> <p></p> <p>To give you guys a comparison, you know clutches in cars right? They basically serve as the mechanism for changing gears in a car  (They are used for connecting/disconnecting the engine from transmission). Similar to that, vim clutch is used for switching from one mode to another in vim/neovim.</p>"},{"location":"personal/vimclutch/#motivation-behind-vim-clutch","title":"Motivation behind VIM Clutch","text":"<ul> <li>Pressing <code>ESC</code> causes your hand to move away from homerow resulting in slight discomfort.</li> <li>To improve your typing speed and reduce the strain on ring finger</li> </ul>"},{"location":"personal/vimclutch/#why-am-i-doing-it","title":"Why am I doing it?","text":"<ul> <li>From the past few months, I have become a hardcore neovim user and have faced this problem of pressing Escape   especially on a full sized keyboard</li> <li>Because its a fun project and would help me learn something new</li> </ul>"},{"location":"personal/vimclutch/#my-modifications","title":"My Modifications","text":"<ul> <li>Pressing the pedal all the time to remain in <code>Insert</code> mode is really a pain. So in my version the pedal acts a button where pressing the pedal results in switching to normal mode from any mode</li> <li>In future I plan to use various combinations of presses to trigger different modes and possibly make my life easier.</li> </ul> <p>Now that the you have understood the definition and motivation behind this project, lets get to the real stuff and start building this device.</p> <p>Note : The instructions given here were performed on a Gentoo. If you wish to do Arduino development on Gentoo head over to https://wiki.gentoo.org/wiki/Arduino to complete the prerequisites.</p>"},{"location":"personal/vimclutch/#components-required","title":"Components Required","text":"<ul> <li>Arduino Board</li> <li>Electronic Foot Pedal</li> <li>Jumper wires</li> </ul>"},{"location":"personal/vimclutch/#building-the-hardware","title":"Building the hardware","text":"<p>Its pretty simple, since our footpedal is acting as the switch, - Connect the live wire from the footpedal into the 5V rail on your Arduino Board. - Connect the ground wire from the footpedal into the ground pin of your Arduino Board. - Connect the data wire from the footpedal into the 8th digital pin of your Arduino board.</p>"},{"location":"personal/vimclutch/#flashingcompiling-the-program-to-the-arduino","title":"Flashing/Compiling the program to the Arduino","text":"<ul> <li>Clone the repository from github using this command <pre><code>git clone --recurse-submodules -j8  git@github.com:gopi487krishna/nvim-clutch.git\n</code></pre></li> <li><code>cd</code> into the newly cloned directory</li> <li>Open the file <code>nvim_clutch_sketch.ino</code> in Arduino IDE and upload it to the Arduino Board</li> </ul>"},{"location":"personal/vimclutch/#what-the-sketch-does","title":"What the sketch does?","text":"<p><pre><code>const int footpedal_pin = 8; // Digital Pin 8 to Read the Input from Pedal\nint footpedal_previous_state=0;\n\nvoid setup(){\n  pinMode(footpedal_pin, INPUT); // We need to recieve data from  footpedal\n  Serial.begin(9600);\n}\n\nvoid loop(){\n  int footpedal_current_state = digitalRead(footpedal_pin); // Check if pressed or released\n  if(footpedal_current_state == 1 &amp;&amp; footpedal_previous_state != footpedal_current_state){\n    Serial.println(1);\n\n  }   \n  footpedal_previous_state = footpedal_current_state;\n  delay(20);\n}\n</code></pre> - Well to give a brief explaination, this code sets the 8th Digital pin as Digital Input and prints  <code>1</code> into the serial port if the button was pressed.  - The if condition makes sure that <code>1</code> is only sent when the button was pressed. Holding the pedal in pressed state will not send multiple <code>1</code> or <code>ON</code> state to the program.</p>"},{"location":"personal/vimclutch/#program-to-send-the-keyboard-event","title":"Program to send the keyboard event","text":""},{"location":"personal/vimclutch/#some-important-points-to-note","title":"Some Important Points to Note","text":"<ul> <li> <p>Here I had a choice to either write a kernel driver or a userspace program to handle the communication. I decided to go with a userspace program since its simple serial communication.</p> </li> <li> <p>To read the data from the serial port, I decided to use a library called CppLinuxSerial It hides all the complexity of performing serial communication and gives a simple interface to work with serial ports.</p> </li> <li> <p>To send the keyboard sequence, I use a library called <code>libxdo</code>. Its a simple library for simulating keyboard input and mouse activity. And as the clever ones among you guessed it, yes it requires Xorg server to work. My usecase was within a X environment and therefore I decided to go through this route. You can write a kernel driver to send keyboard sequence directly without requiring an Xorg server.</p> </li> </ul>"},{"location":"personal/vimclutch/#steps-to-compile-and-install-the-nclutch-program","title":"Steps to compile and install the nclutch program","text":"<ul> <li>Navigate into the github repo that you clone in the previous step.</li> <li>Create a new folder called build</li> <li><code>cd</code> into that folder and enter <pre><code>cmake -DBUILD_TESTS=OFF ..\n</code></pre></li> <li>Now run make to build the program.</li> <li>Run make install to install the program into your system</li> </ul>"},{"location":"personal/vimclutch/#some-important-points-to-note_1","title":"Some Important Points to Note","text":"<ul> <li>In order to understand what the program does, please take a look inside nclutch directory. The code is self explanatory in  nature and quite easy to follow</li> </ul> <p><pre><code>#include &lt;CppLinuxSerial/SerialPort.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;xdo.h&gt;\n\nint main(int argc, char *argv[]) {\n\n  std::string filename;\n\n  if (argc &gt; 1) {\n    filename = std::string(argv[1]);\n  } else {\n    std::cerr &lt;&lt; \"Error : Please provide the path to the device\\n\";\n    return EXIT_FAILURE;\n  }\n\n  /*Screen context*/\n  xdo_t *x = xdo_new(\":0.0\");\n\n  if (x == nullptr) {\n    std::cerr &lt;&lt; \"Error : Failed to create new instance of xdo\\n \";\n    return EXIT_FAILURE;\n  }\n\n  mn::CppLinuxSerial::SerialPort serialport(\n      filename, mn::CppLinuxSerial::BaudRate::B_9600,\n      mn::CppLinuxSerial::NumDataBits::EIGHT, mn::CppLinuxSerial::Parity::NONE,\n      mn::CppLinuxSerial::NumStopBits::ONE);\n\n  /*Block on read and wait until we get atleast 1 byte*/\n  serialport.SetTimeout(-1);\n\n  /*Open the file for communication*/\n  serialport.Open();\n\n  std::string readData; // Dummy var for reading a byte\n\n  while (true) {\n    serialport.Read(readData);\n\n    /*Send escape key to the focused window*/\n    xdo_send_keysequence_window(x, CURRENTWINDOW, \"Escape\", 0);\n  }\n  serialport.Close();\n  delete x;\n\n  return EXIT_SUCCESS;\n}\n</code></pre> - When running <code>nclutch</code> you are required to pass the device path as the argument. Run  <pre><code>sudo dmesg | grep cdc \n</code></pre> to get the device name</p>"},{"location":"personal/vimclutch/#post-installation","title":"Post Installation","text":"<ul> <li>After building nclutch program, you can create a simple service script to start the program automatically after the system boots</li> <li>In my case, I spawn it as a daemon within my window manager script. Please refer to the documentation of your window manager to understand how to spawn a daemon after startup</li> </ul>"},{"location":"personal/vimclutch/#how-is-the-experience-so-far","title":"How is the experience so far?","text":"<p> - I use Vim Clutch with my desktop and tbh its an improved experience. - I have not become the fastest typist in town but the strain on my ring finger has certainly reduced</p>"},{"location":"personal/vimclutch/#special-thanks","title":"Special Thanks !","text":"<p>A special thanks to my friend Nikhil Kumar for helping me complete this  project. This was my very first attempt at working with hardware stuff and his excellent knowledge in embedded electronics helped me get started easily. Also his deep insights on how this project can be improved further (such as using low cost board, introducing new combinations) is really interesting and I am planning to implement them further down the road.</p>"}]}